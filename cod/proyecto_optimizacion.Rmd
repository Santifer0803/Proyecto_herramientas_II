---
title: "Proyecto_optimizacion"
author: "Grupo optimización"
date: "`r Sys.Date()`"
output: html_document
---

# Proyecto grupal CA-0305

Para poder utilizar el proyecto, se iniciará con la descarga de las librarías que se utilizaron (Se pondrán como un comentario ya que cada persona puede tener alguna de estas librerías, de esta manera se podrán elegir las que no se tengan individualmente).

```{r librerias_necesarias}
# Librerías comunes
# install.packages("ggplot2")
# install.packages("dplyr")
# install.packages("readxl")

# Librerías menos comunes
# install.packages("microbenchmark")
# install.packages("future")
# install.packages("furrr")
# install.packages("data.table")
```

Para medir los tiempos de ejecución se utilizará la librería [microbenchmark](https://cran.r-project.org/web/packages/microbenchmark/microbenchmark.pdf), la cual permite medir el tiempo de una función múltiples veces.

```{r librerias_generales}
library(microbenchmark)
library(ggplot2)
```

## Gráficos en paralelo

Inicialmente, se procede a descargar la base de datos a utilizar para generar los gráficos.

```{r descarga_datos}
library(readxl)
muertes.cr <- read_excel("data/muertes_en_costa_rica_2014_2021.xlsx")
```

Se remueven las edades de 15 años o más.

```{r limpieza_edades}
muertes.cr <- muertes.cr[muertes.cr$edads >= 15, ]
```

Se remueven las observaciones de años anteriores a 2014, la base cuenta con muy pocas.

```{r limpieza_annos}
muertes.cr <- muertes.cr[muertes.cr$anodef >= 2014, ]

muertes.cr <- muertes.cr[muertes.cr$anotrab >= 2014, ]

muertes.cr <- muertes.cr[muertes.cr$anodeclara >= 2014, ]
```

Se procede a corregir algunos errores ortográficos.

```{r errores_ortograficos}
# Se pondrá todo sin tílde, para evitar errores al correr el código
muertes.cr$estcivil <- gsub("Ã³", "o", muertes.cr$estcivil)

muertes.cr$ocuparec <- gsub("Ã¡", "a", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Ã©", "e", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Ã", "i", muertes.cr$ocuparec)

muertes.cr$regsalud <- gsub("Ã", "i", muertes.cr$regsalud)

muertes.cr$regsalud <- gsub("i³", "o", muertes.cr$regsalud)

muertes.cr$provincia <- gsub("Ã©", "e", muertes.cr$provincia)

muertes.cr$provincia <- gsub("Ã³", "o", muertes.cr$provincia)

muertes.cr$provocu <- gsub("Ã©", "e", muertes.cr$provocu)

muertes.cr$provocu <- gsub("Ã³", "o", muertes.cr$provocu)

muertes.cr$provregis <- gsub("Ã©", "e", muertes.cr$provregis)

muertes.cr$provregis <- gsub("Ã³", "o", muertes.cr$provregis)

muertes.cr$reginec <- gsub("Ã", "i", muertes.cr$reginec)

muertes.cr$reginec <- gsub("i³", "o", muertes.cr$reginec)

muertes.cr$edadsrec <- gsub("100 y mÃ¡s", "100 - 121", muertes.cr$edadsrec)

muertes.cr$autopsia <- gsub("Ã©", "e", muertes.cr$autopsia)

muertes.cr$autopsia <- gsub("Ã", "i", muertes.cr$autopsia)

muertes.cr$asistmed <- gsub("Ã©", "e", muertes.cr$asistmed)

muertes.cr$asistmed <- gsub("Ã", "i", muertes.cr$asistmed)

muertes.cr$reginec <- gsub("Paci­fico", "Pacifico", muertes.cr$reginec)

muertes.cr$regsalud <- gsub("Paci­fico", "Pacifico", muertes.cr$regsalud)
```

Se cambian las nacionalidades distintas a Costa Rica.

```{r cambio_nacionalidades}
muertes.cr$nacionalid <- gsub("^(?!Costa Rica$).*", "Extranjero", muertes.cr$nacionalid, perl = TRUE)
```

Debido a la baja cantidad de observaciones, en el estado civil se hará un grupo llamado “otros” para los que están en estado civil: ignorado, unión libre, menor y separado.

```{r limpieza_civil}
muertes.cr$estcivil <- gsub("Ignorado", "Otros", muertes.cr$estcivil)

muertes.cr$estcivil <- gsub("Union libre", "Otros", muertes.cr$estcivil)

muertes.cr$estcivil <- gsub("Separado", "Otros", muertes.cr$estcivil)

muertes.cr$estcivil <- gsub("Menor", "Otros", muertes.cr$estcivil)
```

Nuevamente, por la baja cantidad de observaciones en algunas ocupaciones, se juntarán algunos grupos, en este caso se harán 2 grupos llamados “Trabajadores activos” y “Otros”, que contienen a las siguientes ocupaciones:

Trabajadores activos: “Profesionales cientificos e intelectuales”, “Agricultores y trabajadores calificados agropecuarios, forestales y pesqueros”, “Ocupaciones elementales”, “Trabajadores de los servicios y vendedores de comercios y mercados”, “Operadores de instalaciones y maquinas y ensambladores”, “Tecnicos y profesionales de nivel medio”, “Oficiales, operarios y artesanos de artes mecanicas y de otros oficios”, “Personal de apoyo administrativo” y “Directores y gerentes”.

Otros: “Pensionado”, “Persona con discapacidad”, “Estudiante”, “Mal especificadas” y “Privado de libertad”.

```{r limpieza_ocupaciones}
# Grupo de Trabajadores activos
muertes.cr$ocuparec <- gsub("Profesionales cienti­ficos e intelectuales", "Trabajadores activos", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Agricultores y trabajadores calificados agropecuarios, forestales y pesqueros", "Trabajadores activos", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Ocupaciones elementales", "Trabajadores activos", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Trabajadores de los servicios y vendedores de comercios y mercados", "Trabajadores activos", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Operadores de instalaciones y maquinas y ensambladores", "Trabajadores activos", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Tecnicos y profesionales de nivel medio", "Trabajadores activos", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Oficiales, operarios y artesanos de artes mecanicas y de otros oficios", "Trabajadores activos", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Personal de apoyo administrativo", "Trabajadores activos", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Directores y gerentes", "Trabajadores activos", muertes.cr$ocuparec)

# Grupo de Otros
muertes.cr$ocuparec <- gsub("Pensionado", "Otros", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Persona con discapacidad", "Otros", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Estudiante", "Otros", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Mal especificadas", "Otros", muertes.cr$ocuparec)

muertes.cr$ocuparec <- gsub("Privado de libertad", "Otros", muertes.cr$ocuparec)
```

Se eliminan algunas de las columnas que no se usarán para la base.

```{r eliminar_columnas}
library(dplyr)
muertes.cr <- muertes.cr %>% 
  select(-pc, -causamuer, -des_causa, -pcocu, -nacmadre, -pcregis, -gruposcb, -instmurio)
```

Se ordena la columna de grupo etario.

```{r ordenar_gretario}
muertes.cr$edadsrec <- factor(muertes.cr$edadsrec, levels = c("15 - 19", "20 - 24", "25 - 29", "30 - 34", "35 - 39", "40 - 44", "45 - 49", "50 - 54", "55 - 59", "60 - 64", "65 - 69", "70 - 74", "75 - 79", "80 - 84", "85 - 89", "90 - 94", "95 - 99", "100 - 121"))
```

Con la limpieza realizada, se procede a realizar el ejercicio de los gráficos. Para esto se usó el paquete [furrr](https://furrr.futureverse.org), este permite realizar ciclos en paralelo, lo cual se puede observar que aumenta en gran medida la [eficiencia](https://github.com/victorcaquilpan/LecturaExcelConR). Se realizan gráficos de barras para las categóricas e histogramas para las numéricas.

```{r graficos_paralelo}
library(furrr)
library(future)

# Definimos la cantidad de gráficos que vamos a generar
num.graf <- ncol(muertes.cr)

# Cargamos el plan para paralelizar
plan(multisession)

# Definimos las funciones que generen los gráficos deseados
fun.histograma <- function(df, indice_col){
  ggplot(data.frame(valor = df[[indice_col]]), aes(x = valor)) +
    geom_histogram(binwidth = 1, fill = "blue", color = "black") +
    labs(y = "Frecuencia", caption = "Fuente: elaboración propia") +
    theme_minimal()
}

fun.barras <- function(df, indice_col){
  ggplot(data.frame(valor = df[[indice_col]]), aes(x = valor)) +
    geom_bar(fill = "skyblue") +
    labs(y = "Cantidad", caption = "Fuente: elaboración propia") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# Definimos una función para identificar cuáles columnas son categóricas
indices.categoricos <- function(x) is.character(x) || is.factor(x)

# Guardamos los índices correspondientes
categoricos <- which(sapply(muertes.cr, indices.categoricos))
numericos <- which(!sapply(muertes.cr, indices.categoricos))

# Generamos los gráficos histogramas en paralelo
future_map(numericos, ~ fun.histograma(muertes.cr, .x))

# Generamos los gráficos de barras en paralelo
future_map(categoricos, ~ fun.barras(muertes.cr, .x))
```

Con lo anterior, probamos el tiempo que tardan las funciones.

```{r tiempo_graficos}
# Cargamos el plan para paralelizar
plan(multisession)

# Tomamos los tiempos 10 veces e imprimimos los resultados
(microbenchmark(future_map(numericos, ~ fun.histograma(muertes.cr, .x)), future_map(categoricos, ~ fun.barras(muertes.cr, .x)), times = 10))
```

Se realiza un DataFrame con el tiempo (en segundos) promedio de los histogramas y de los gráficos de barras respectivamente, cada integrante del grupo lo añade manualmente con los tiempos del chunk anterior.

```{r df_tiempos}
# Dentro de los mismos vectores, se agregan los demás datos
tiempos.graficos <- data.frame(
  integrante = c("Santiago", "Eyeri"),
  histogramas = c(10.09174, 4.83059),
  barras = c(20.44117, 8.06775)
)
```

## Media móvil

Inicialmente, se descarga la base para reemplazar la media móvil en una de sus columnas. Para modificar esta base, se hará un objeto de tipo [data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html), este se trata de una versión más eficiente de los data.frames que R trae por defecto, es necesario mencionar que los data.table tienen una sintaxis similar a SQL.

```{r dascarga_datos_2}
library(data.table)
library(readxl)

# Se descargan los datos normalmente
base.salarios <- read_excel("data/Base_salarios.xlsx")

# Se pasan a data.table
base.salarios <- setDT(base.salarios)
```

Con el objeto necesario, se probará un método manual, pues las funciones existentes devuelven aún más nulos de los que hay en el vector original. Para realizar este proceso más rápido se probó a paralelizar el código, pero esto resultó más ineficiente que la versión final.

```{r media_movil}
# Se hace una copia de la columna a copiar
copia.col <- base.salarios$`Salario base`

# Se crea la función para cambiar los nulos por la media movil en paralelo
media.movil <- function(col.nulos, banda) {
  # Se obtinenen los índices de los valores nulos y la cantidad de filas
  indices.nulos <- which(is.na(base.salarios$`Salario base`))
  filas <- length(col.nulos)
  
  # Iteramos a través de los nulos
  for (i in indices.nulos) {
    # Se obtiene el vector alrededor del valor a imputar
    vec.num <-
      c(col.nulos[max(1, (i - banda)):(i - 1)], (i + 1):min(filas, (i + banda)))
    
    # Se sustituye el valor por el promedio del vector anterior, ignorando los nulos
    col.nulos[i] <- mean(vec.num, na.rm = TRUE)
  }
  return(col.nulos)
}

# Prueba de la función
(sum(is.na(media.movil(copia.col, 4))))

# La variable original sigue sin alterarse, solo se modifica localmente
(sum(is.na(copia.col)))
```

Con la función anterior, se realizan 10 simulaciones para ver su tiempo promedio.

```{r tiempo_media}
(microbenchmark(media.movil(copia.col, 5), times = 10))
```

Hacemos el DataFrame con los valores promedio de cada integrante (fijarse en la unidad de tiempo, pues los datos son en segundos).

```{r df_tiempos}
# Dentro de los mismos vectores, se agregan los demás datos
tiempos.mediam <- data.frame(
  integrante = c("Santiago", "Eyeri"),
  media_movil = c((3.15827) / 1000, (6.7584) / 1000)
)
```

## Operaciones matriciales

Inicialmente se intentaron usar librerías como Matrix, bigmemory, LAPLACK, BLAS, bigalgebra o expm, pero algunas de estas requieren de una instalación externa y más compleja que una librería común y corriente, además de que dichas librerías no optimizan la multiplicación elemento a elemento sino que optimizan el calculo matricial de matrices, o se especializan en otros tipos de procedimientos con matrices, lo cual no es lo que se quiere en este ejercicio.

Esto quiere decir que, por ejemplo, al hacer A %^% 2 o, lo que es lo mismo, A %*% A, se hace la multiplicación matricial de A con A y no la multiplicación elemento a elemento de A con A, que es lo deseado. También se intentó paralelizar el código usando las librerías doParallel y foreach, pero resultó ser bastante más ineficiente hacer esto que hacerlo por defecto.

Así, se decidió que la mejor manera de hacer este ejercicio es hacerlo con lo que trae R por defecto; es decir, crear una matriz con matrix() y utilizar el operador ^ para elevar a la 100 elemento a elemento, así como * y + para multiplicarla por 10 y sumarle 5, respectivamente.

Si bien el tiempo de ejecución puede parecer alto, es lo mejor que se pudo encontrar que está a nuestro alcance.

```{r}

library(microbenchmark)

# Se definen las dimensiones de la matriz
n <- 10000

# Se crea la matriz con las dimensiones deseadas
matriz <- matrix(runif(n^2), n, n)

operacion <- function(matriz){
  
  return(((matriz ^ 100) * 10) + 5)
  
}

# Por último se determina el tiempo promedio de ejecución (en segundos) de realizar el proceso 10 veces

plan(multisession)

(microbenchmark(operacion(matriz), times = 10))

```

```{r}

# Se guarda este tiempo por integrante en un dataframe
tiempos.operaciones.matrices <- data.frame(integrante = c("Eyeri"), tiempo = c(5.068372))

```

## Eliminación de columnas por porcentaje de valores nulos

Similar al ejercicio de media móvil, se inicia descargando la base de datos y se modifica a un objeto de tipo data.table. Luego se crea la función que hace lo deseado y se mide el tiempo promedio de ejecución usando microbenchmark. Esta función ya hace lo requerido en un tiempo considerablemente rápido, por lo que si fuera posible mejorar el tiempo de ejecución no habría una diferencia significativa. 

```{r}

library(microbenchmark)
library(data.table)
library(readxl)

base.salarios <- read_excel("data/Base_salarios.xlsx")

base.salarios <- setDT(base.salarios)

# Función que elimina las columnas de un dataframe en las cuales el porcentaje de valores nulos represanta un porcentaje mayor al indicado por el usuario
eliminar.columnas <- function(df, porcentaje){
  
  filas <- length(df[[1]])
  
  i <- 1
  
  while(i <= length(df)){
      
    cantidad_na <- sum(is.na(df[[i]]))
      
    if((cantidad_na / filas) > porcentaje){
        
      df <- subset(df, select = -i)
        
    } # fin if
    
    i <- i + 1
    
  } # fin while i
  
  return(df)
  
}

```

Prueba de la función y tiempo promedio de ejecución

```{r}

prueba.1 <- eliminar.columnas(base.salarios, 0.1)

# Como se puede ver, en ninguna columna del dataframe se presenta una cantidad de valores nulos mayor al 10%, por lo que se procede a probar la función con un porcentaje de 1% para que se eliminen al menos 2 columnas y se pueda ver mejor el tiempo de ejecución de la función

prueba.2 <- eliminar.columnas(base.salarios, 0.01)

# Ahora se procede a determinar el tiempo promedio de ejecución (en segundos) de hacer el proceso 10 veces

plan(multisession)

(microbenchmark(eliminar.columnas(base.salarios, 0.01), times = 10))

```

Por último, se hace un dataframe con los tiempos de ejecución de cada integrante

```{r}

tiempos.eliminar.columnas <- data.frame(integrante = c("Eyeri"), tiempo = c((741.48) / 1000))

```








